# 内存安全性
理解所有权和借用
所有的程序都是要和计算机内存打交道的如何从内存中申请空间来存放程序的运行内容,在合适释放这些空间
为了解决这个问题,出现了三种流派
gc,手动管理,所有权管理

## 堆和栈
堆和栈的核心目标就是为程序在运行时提供可供使用的内存空间
在栈中的所有数据必须占用已知且固定的内存空间
与栈不同,当向堆上放数据时,需要请求一定大小的内存空间.操作系统在堆的某处找一个足够大的空位,标记为已使用,在返回一个标记该地址的指针,简称分配,接着该指针会被推入栈中
栈上的数据会比堆上的数据更加高效

当一个函数被调用时,传递给函数的参数被一次压入栈中,当函数调用同结束时,这些值以相反的顺序移除,
  因为堆上的数据缺乏组织,这些数据何时分配何时释放非常重要,否则堆上将产生内存泄漏,这些数据永远无法被回收

## 所有权原则
  每一个值被一个变量所拥有
  一个值同时只能被一个变量所拥有
  当变量离开作用域时这个值就被丢弃

## Codes
  ```Rust
  let x = 5;
  let y = x;
  let s1 = String::from("hello")
  let s2 = s1;
  ```
  栈上的简单变量都是通过自动拷贝的方式来赋值的,
  堆上的变量,如String是一个复杂类型,由存储在栈中的堆指针,字符串长度,字符串容量共同组成,其中堆指针是最重要的,他指向了真实存储字符串内容的堆内存,至于长度和容量,容量是堆内存分配空间的大小,长度是目前已经使用的大小.
  此时,发生拷贝时,会有两种情况.
  第一种,拷贝String和存储在堆上的字节数组,对于性能的影响很大.
  第二种,只拷贝String本身,不涉及堆上的内存,此时会带来新的问题,一个值只允许有一个所有者,而现在,这个值(堆上的真实字符串数据)有了两个所有者,当变量离开作用域,清理堆内存时,会发生二次释放的错误.

## 引用和借用
  如果仅仅支持通过转移所有权的方式获取一个值,那么程序会变得很复杂,所以我们可以使用某个变量的指针和引用.
  Rust通过借用这个概念完成上述目的
  ```Rust
  fn main(){
    let x = 5;
    let y = &x;
    let s = String::from("hello");
    let s1 = &mut s;
    let s2 = &mut s;
    change(&mut s)
  }
fn calculate_length(s:&String) -> usize{
  s.len()
}
fn change(some_string:&String){
  some_string.push_str(",world");
}
```
引用默认不可变
可变引用只能同时存在一个
可变引用和不可变引用不能同时存在

## 悬垂引用



